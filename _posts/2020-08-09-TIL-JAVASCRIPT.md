---
layout: post
title: "TIL-JAVASCRIPT"
subtitle: "JAVASCRIPT - 데이터 타입"
background: '/img/posts/02.jpg'
---

# 자바스크립트 데이터 타입
- 원시타입(primitive data type)
    - number
    - string
    - boolean
    - null
    - undefined
    - symbol(New in ECMAScript 6)
- 객체 타입 (Object data type)
    - object
    - 위의 원시타입을 제외한 나머지 값들 (함수, 배열, 정규표현식 등)은 모두 객체

### 원시타입
**원시 타입의 값은 변경 불가능한 값(immutable value)이며 pass-by-value(값에 의한 전달) 이다.**<br/>
1. number
- 숫자 타입의 값은 배정밀도 64비트 부동소수점 형(double-precision 64-bit floating-point format : -(253 -1) 와 253 -1 사이의 숫자값)을 따른다. 즉, 모든 수를 실수를 처리하며 정수만을 표현하기 위한 특별한 데이터 타입(integer type)은 없다.
- 2진수, 8진수, 16진수 리터럴은 메모리에 동일한 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.
- 자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수를 처리한다.
    - Infinity : 양의 무한대
    - Infinity : 음의 무한대
    - NaN : 산술 연산 불가(not-a-number)

2. string
-  문자열은 0개 이상의 16bit 유니코드 문자(UTF-16) 들의 집합으로 대부분의 전세계의 문자를 표현할 수 있다. 문자열은 작은 따옴표(‘’) 또는 큰 따옴표(“”) 안에 텍스트를 넣어 생성한다. 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다.
```JAVASCRIPT
var str = "string"; // 큰 따옴표
str = 'string';     // 작은 따옴표
str = `string`;     // 백틱(ES6 템플릿 리터럴)
```

```JAVASCRIPT
var str = 'Hello';
str = 'world';
```
=> 첫번째 구문이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 메모리에 생성된 문자열 ‘Hello’의 메모리 주소를 가리킨다. 그리고 두번째 구문이 실행되면 이전에 생성된 문자열 ‘Hello’을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자열 ‘Hello’와 ‘world’는 모두 메모리에 존재하고 있다. 변수 str은 문자열 ‘Hello’를 가리키고 있다가 문자열 ‘world’를 가리키도록 변경되었을 뿐이다.
- 문자열은 **유사배열**로 인덱스를 통해 접근이 가능하다

3. boolean
- true, false 뿐
- 비어있는 문자열, null, undefined, 0은 false로 간주

4. undefined
- undefined가 유일. 
- 자바스크립트 엔진이 undefined로 초기화 시키기 때문에 선언 이후 값을 할당하지 않은 변수는 undefined값을 가진다.
- 변수의 값이 없음을 나타내고 싶을 때는 null을 할당

5. null
- null타입은 null이 유일
- 대소문자 구별!
- 의도적으로 변수에 값이 없음을 나타낼 때 사용하며, 변수가 기억하는 메모리주소의 참조 정보를 제거하는 것을 의미한다.
- 자바스크립트 엔진은 누구도 참조하지 않는 메모리 영역에 대해 가비지 콜렉션을 수행할 것이다.
- 또는 함수가 호출되었으나 유효한 값을 반환할 수 없는 경우, 명시적으로 null을 반환하기도 한다.
- **typeof**로 null을 연산하면 object가 나오는데 이것은 자바스크립트의 설계상 오류로, null 타입을 확인할 때 ***일치 연산자(===)*** 를 사용해야 한다.

6. symbol
- ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다. 심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다.

### 객체 타입
- 자바스크립트 객체는 키(이름)와 값으로 구성된 프로퍼티(property)의 집합이다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다.
- 따라서 프로퍼티 값으로 함수를 사용할 수도 있으며 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라 부른다.
- 객체는 pass-by-reference(참조에 의한 전달) 방식으로 전달된다.

# 변수
## 호이스팅
var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다. 

### 변수의 생성 단계
- 선언 단계(Declaration phase)
<br/>변수 객체(Variable Object)에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.
- 초기화 단계(Initialization phase)
<br/>변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다.
- 할당 단계(Assignment phase)
<br/>undefined로 초기화된 변수에 실제값을 할당한다.

var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다.
<br/>즉, 스코프에 변수가 등록되고 변수는 메모리에 공간을 확보한 후 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라한다.

let, const 키워드를 사용하면 블록 레벨 스코프를 사용 할 수 있다.
### 함수 레벨 스코프 / 블록 레벨 스코프
- 함수 레벨 스코프(Function-level scope)
<br/>함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.
- 블록 레벨 스코프(Block-level scope)
<br/>코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.

### var 키워드 문제점
1. 함수 레벨 스코프
    - 전역 변수 남발
    - for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다.
2. var 키워드 생략 허용
    - 의도하지 않은 변수의 전역화
3. 중복 선언 허용
    - 의도하지 않은 변수값 변경
4. 변수 호이스팅
    - 변수를 선언하기 전에 참조가 가능하다.

변수의 유효 범위(scope)는 좁을수록 좋다.